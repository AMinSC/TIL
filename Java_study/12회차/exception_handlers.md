# 예외 처리

# 예외 처리

## 예외
개발자가 프로그램을 작성하는 과정에서 실수를 하거나 사용자가 잘못된 값을 입력하면 오류가 발생할 수 있습니다.

다양하게 발생하는 오류 중 개발자가 해결할 수 있는 오류를 `예외(exception)`, 이러한 예외가 발생했을 때 이를 적절히 처리하는 것을 `예외처리`라고 합니다.

### 예외와 에러의 차이점
자바에서 제공하는 예외 처리 메커니즘을 이해하기 전에 `예외(exception)`와 `에러(error)`의 의미를 정리해 보겠습니다.

먼저 예외는 `연산 오류, 숫자 포맷 오류 등과 같이 상황에 따라 개발자가 해결할 수 있는 오류`를 말하며, 여기서 `해결할 수 있는`의 의미는 오류 자체를 수정할 수 있다는 것이 아니라 오류가 발생했을 때 차선책을 선택하는 것을 말합니다.
반면 에러는 JVM 자체에서 발생하는 오류로, `개발자가 해결할 수 없는 오류`를 말합니다.

> 오류가 발생했을 때 차선책을 제시함으로써 오류를 피하는 과정을 `예외 처리`라고 합니다.

int a = 1 / 0 은 분모는 절대 0이 될 수 없어 연산 자체가 불가능하므로 예외가 발생하고, 대신해서 개발자가 a값에 -1 값 혹은 그 외 다른 값을 직접 대입하는 것을 예외 처리라고 합니다.
이렇게 개발자가 예외 처리하면 프로그램은 종료되지 않고 계속 실행됩니다.

에러는 차선책을 선택하는 것 자체도 불가능할 때를 말하며, 대표적인 예로는 메모리가 꽉 찼을 때, 쓰레드가 죽었을 때 등을 들 수 있습니다.

즉, 예외는 `개발자가 처리할 수 있는 오류`, 에러는 `개발자가 처리할 수 없는 오류`를 말합니다.

자바에서 예외의 최상위 클래스는 Exception 클래스, 에러의 최상위 클래스는 Error 클래스입니다.
이 2개의 클래스는 모두 Throwable 클래스를 상속하고 있습니다.
따라서 에러와 예외 모두 Throwable 클래스의 모든 기능을 포함합니다.


### 예외 클래스의 상속 구조
Throwable 클래스를 상속받은 Exception 클래스는 다시 `일반 예외(checked exception)` 클래스와 `실행 예외(unchecked(tuntime) exception)` 클래스로 나뉩니다.

![Exception_class](image.png)

- `일반 예외(Checked Exception)`: 컴파일 전에 체크
Exception 클래스에서 직접 상속받은 예외 클래스들이 처리하는 일반 예외는 컴파일 전에 예외 발생 문법을 검사(check)하며, 예외 처리를 하지 않으면 문법 오류가 발생합니다.

- `실행 예외(Unchecked Exception=Runtime Exception)`: 실행할 때 체크
반면 RuntimeException 클래스를 상속받은 예외 클래스들이 처리하는 실행 예외는 컴파일전이 아니라 실행할 때 발생하는 예외로, 예외 처리를 따로 하지 않더라도 문법 오류가 발생하지 않습니다.
다만, 프로그램 실행 시 프로그램이 강제 종료되는 이유는 대부분 실행 예외 때문이므로 이에 대한 세심한 주의가 필요합니다.


### 일반 예외 클래스
앞에서 설명한 것처럼 일반 예외는 예외 처리를 하지 않으면 문법 오류를 발생시켜 컴파일 자체가 불가능합니다.
이러한 일반 예외를 처리하는 일반 예외 클래스에 대해 알아보겠습니다.

- InterruptedException
Thread.sleep(시간) 메서드는 일정 시간 동안 해당 쓰레드를 일시정지 상태로 만드는 Thread 클래스의 정적 메서드입니다.
이 메서드는 일반 예외가 발생할 수 있기 때문에 반드시 예외 처리를 해야 합니다.

> 쓰레드는 프로그램 실행 과정에서 CPU를 사용하는 최소 단위로, 프로세스 내에 존재합니다.

- ClassNotFoundException
Class.forName("패키지명.클래스명")은 클래스를 동적으로 메모리에 로딩하는 메서드로, 해당 클래스의 정보를 담고 있는 Class 타입의 객체를 리턴합니다.
만일 클래스를 메모리에 동적으로 로딩하는 과정에서 해당 클래스가 존재하지 않을 때는 ClassNotFoundException이 발생하므로 이에 대한 예외 처리르 반드시 해줘야 합니다.

> 실제 java.lang.Object 클래스가 존재한다 하더라도 예외 처리를 하지 않으면 문법 오류가 발생합니다.
즉, 실제 클래스의 존재 유무와 상관없이 예외가 발생할 수 있는 코드인지가 중요합니다.

- IOException
IOException은 자바 입출력 부분에서 자주 보게 될 일반 예외로, 콘솔이나 파일에 데이터를 쓰거나(write()) 읽을(read()) 때 발생하며, 반드시 IOException에 대한 예외 처리를 해야 합니다.

- FileNotFoundException
파일을 읽을 때 해당 결로에 파일이 없으면 FileNotFoundException이 발생합니다.
이 또한 실제 파일의 존재 유무와는 상관없이 파일이 존재하지 않을 가능성이 있는 코드이기 때문에 반드시 예외 처리를 해야 문법 오류가 발생하지 않습니다.

- CloneNotSupportedException
자바의 모든 클래스는 Obejct 클래스를 상속합니다.
즉, 이는 Obejct의 모든 메서드를 사용할 수 있다는 뜻입니다.
Object 클래스의 메서드 중 clone()은 자신의 객체를 복사한 클론객체를 생성해 리턴하는 메서드입니다.
다만, 이를 위해 복사의 대상이 되는 클래스는 반드시 Cloneable 인터페이스를 상속해야 합니다.
쉽게 말해, `해당 클래스가 복사 기능을 제공해야 한다는 것입니다.`
만약 Cloneable 인터페이스를 상속하지 않은 클래스의 객체를 복사하기 위해 clone() 메서드를 호출하면 CloneNotSupportedException이 발생합니다.

참고로 아래 예제에서 class B의 내부에 추가 기능이 없는데도 Obejct 클래스의 clone() 메서드를 오버라이딩 한 이유는 protected의 접근 지정자를 갖는 clone() 메서드를 클래스 A 내부에서 호출할 수 있도록 하기 위해서입니다.

> CLoneable은 내부에 추상 메서드를 포함하고 있지 않으며, 단순히 해당 클래스가 복사 기능을 제공함을 나타내는 `마커(marker)`의 기능만을 수행하는 인터페이스입니다.

```java
class B {
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
public class A {
    public static void main(String[] args) {
        B b1 = new B();
        B b2 = (B) b1.clone();
    }
}
```


### 실행 예외
일반 예외는 예외 처리를 해 주지 않으면 문법 오류가 발생하기 때문에 실행 자체가 불가능한 반면, 실행 예외는 문법 오류가 발생하지 않습니다.
그렇기 때문에 예외 처리 없이 컴파일과 실행이 가능하지만, 실행 중 실행 예외가 발생하면 프로그램은 강제 종료됩니다.

실행 예외를 처리하는 클래스는 Exception의 자식 클래스인 Runtime Exception 클래스의 자식 클래스들입니다.

- ArithmeticException
Arithmetic의 사전적인 뜻은 `산술` 또는 `연산`입니다.
즉, ArithmeticException은 연산 자체가 불가능할 때 발생하는 실행 예외입니다.
수학식에서 절대 존재할 수 없는 대표적인 연산은 분모가 0일 때입니다.
이 연산을 수행하도록 하면 예외가 발생하고, 이때 예외 처리를 하지 않으면 예외가 발생했을 때 실행 중인 프로그램은 예외 발생 상황을 출력하고 강제 종료됩니다.

- ClassCastException
상속 관계에 있는 클래스 간의 업캐스팅은 항상 가능하지만, 다운캐스팅은 가능할 수도, 불가능할 수도 있습니다.
ClassCastException은 다운캐스팅이 불가능한 상황에서 다운캐스팅을 시도할 때 발생합니다.

- ArrayIndexOutOfBoundsException
ArrayIndexOutOfBoundsException은 이름에서 유추할 수 있는 것처럼 배열의 인덱스를 잘못 사용했을 때 발생합니다.
배열의 인덱스는 항상 0 ~ (배열의 길이 - 1)까지의 값만 사용할 수 있습니다.
만일 이 범위를 벗어나게 인덱스를 사용하면 예외가 발생합니다.

- NumberFormatException
문자열을 정수값으로 변환하고자 할 때는 `Integer.parseInt("문자열")`, 실수값으로 변환하고자 할 때는 `Double.parseDouble("문자열")`을 사용해야 합니다.
이렇게 문자열을 숫자 또는 실수로 변환할 때 문자열이 변환하고자 하는 숫자 형식이 아니면 변환이 실패하는데, 이때 발생하는 예외입니다.

> 문자열을 불리언값(true, false)으로 변환하는 과정은 문자열을 정수나 실수로 변환할 때와 다르게 동작합니다.
숫자가 아니기 때문에 변환하는 과정에서는 NumberFormatException이 발생하지 않습니다.

```java
Boolean.parseBoolean("true");       // true
Boolean.parseBoolean("false");      // false
Boolean.parseBoolean("true123");    // false
Boolean.parseBoolean("");           // false
```

이 예에서 알 수 있는 것처럼 문자열을 불리언값으로 변경할 때는 문자열이 "true"인지만 확인하면 됩니다.
불리언값으로 변환하고자 하는 문자열이 "true"일 때만 `true` 값으로 변환되고, 이외의 모든 문자열, 심지어 비어 있는 문자열도 `false`값으로 변환합니다.


- NullPointException
참조 변수가 실제 객체를 가리키고 있지 않은 상황에서 필드나 메서드를 호출할 때 발생합니다.
여기서 null은 위칫값을 저장하는 참조 변수의 초깃값으로만 사용할 수 있으며, 현재 가리키고(pointing)있는 객체가 없다는 것을 의미합니다.
객체를 가리키고 있지도 않는데 해당 위치에 가서 객체 안에 있는 멤버를 실행하라고 명령하니 수행할 수 없는 것입니다.


실행 예외는 예외 처리를 하지 않아도 문법 오류가 발생하지는 않지만, 실행 중인 프로그램이 강제 종료되는 주요 원인이 됩니다.
이는 매우 치명적인 단점이기 때문에 이를 방지하기 위해서는 실행 예외들도 적절한 예외 처리가 필요합니다.

## 예외 처리

### 예외 처리 문법

### 예외 처리 과정

### 다중 예외 처리

### 리소스 자동 해제 예외 처리

## 예외 전가

### 예외 전가 문법

## 사용자 정의 예외 클래스

### 사용자 정의 예외 클래스 생성 방법

### 예외 클래스의 메서드

### 사용자 정의 예외 클래스의 사용 예
